\chapter{Discussion} \label{ch:discussion}
The problem formulation in section~\ref{sec:problem-formulation} can be summarized to:
What are the differences in code structure and development effort for two different development methods for encapsulating an existing web application in a mobile application to utilize native functions?

Our results show that developing such a mobile application in the PhoneGap framework requires less development effort than in the Android framework. A reason for this might be that calls to native functions are handled on a higher abstraction level. Another reason is that 10 classes were used in the Android framework compared to an eqvuivalent to 4 classes in the PhoneGap framework.

The structure that we suggested in the Android framework is modular, separating creation of a request for a native function, handling of the data passed back from the request and communication with the web application layer. The PhoneGap framework also separates the communication with the web application layer, but a request for a native function and handling of the data passed back is located in the same file. 

The mobile application developed in the PhoneGap framework has fewer steps from receiving a request from the web application layer to pass the data back, see flowchart~\ref{fig:nativeflow} and~\ref{fig:phonegapflow}. This suggests that the application developed in the PhoneGap framework has a less complex structure then the application developed in Android framework.

The PhoneGap framework has a higher abstraction level of calls to native functions. That allows for fewer logical lines of code, but there is a downside. The downside is that one has less freedom in terms of customizing the behavior. The loss of freedom makes no difference for a simple mobile application such the one developed, but as Kohan and Montanez points out for a more complex application it might be a problem, see section~\ref{subsec:phonegap}. 

In the Android framework there is a closer relation to the Android System/Hardware, however this comes with a requirement of boilerplate code. That is one of the reasons that the mobile application that was developed in the Android framework had more than double the logical lines of code. This closer relation means that the developer can have a better control over the application lifecycle. The closer relation also means that basic knowledge of Android is needed. If the developer has no prior knowledge of Android this means a starting cost. 

Encapsulating the web application front-end in the PhoneGap framework was made at the cost of a security flaw. The web application front-end was encapsulated by use of an IFrame. To be able to use an IFrame the web applications X-Frame-Options response header was removed which makes it possible to use the web application for ClickJacking, see section~\ref{sec:iframe}. 

There are other ways of encapsulating the front-end of a web application in the PhoneGap framework than by using an IFrame. Another way would be to use a plugin that is available in the PhoneGap API called inAppBrowser. By using inAppBrowser a web page can be loaded into the mobile application and the mobile application layer can execute the web page’s JavaScript functions. If the web page would like to send a request to the mobile application layer the mobile application layer can listen to such requests by the use of polling.  This could be an alternative to using an IFrame that would not expose the web application to be used for ClickJacking. 

To compare the development effort the software metric logical lines of code were used. Logical lines of code were chosen since it is easy to understand, measurable between two programming languages and simple to calculate. Other ways of measuring lines of code or other software metrics could have been used to measure development effort or other properties. To measure more properties and also measure development effort in other ways would have provided a more nuanced result and a fuller picture. For example Halsted's approach, described in section~\ref{sec:lines-of-code}, could have been used to measure the development effort. Another property that could have been measured would have been cyclomatic complexity. Cyclomatic complexity measures the number of linearly independent paths through a program’s source code. 

The result of this study is drawn from one small and simple project. This makes it hard to draw any conclusions about using the two development methods for medium and large projects. It raises the question whether developing in the PhoneGap framework in bigger projects or using more advanced features would still score lower in development effort. One interesting question would be whether the proposed structure in the development methods provide a good bone structure for more complex projects? Or would the structure crumble? The measurement and proposed structure is based on this single project. To get a more reliable result it would be interesting to collect data from a number of projects where a mobile application, encapsulating an existing web application, has been developed in both development methods.

The structure we proposed in the web application, to be able to run both in a web browser and in a mobile application, makes use of the adapter pattern. This makes it easy to further extend web applications functionality. If a new function has no connection to native functionality, such as an animation, the function can be implemented as if the mobile application did not exist. When new functionality is needed which includes native functionality, such as getting information from the accelerometer, then the web application need at least three functions. The first function is needed to make the request to the mobile application and a second function is needed which determines the functionality on a browser. Finally a function which handles the data which is passed back from the request. 
